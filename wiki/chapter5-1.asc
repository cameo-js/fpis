= 5 엄격성과 나태성
김지수 <kjs8469@gmail.com>
1.0, 2017-02-06
:toc:

== 개요

* map, filter, foldLeft, foldRight, zipWith 등등 목록에 대한 연산은 주어진 입력 목록 전체를 훑고 새로운 목록을 결과로 돌려줌
* 놀이용 카드 한 벌에서
  ** 홀수 카드를 모두 제거하고
  ** 모든 퀸 카드를 뒤집는다
* *이상적인 방법*으로는
  ** 한번만 훑으면서('순회[traversal]') 홀수 카드를 제거하고
  ** 퀸 카드를 찾는 작업을 동시에 수행
* *비효율적인 방법*으로는
  ** 홀수 카드를 모두 제거한 후
  ** 남은 카드에서 퀸을 찾는 것

.비효율적인 방법의 스칼라 코드
----
scala> List(1,2,3,4).map(_ + 10).filter(_ % 2 == 0).map(_ * 3) <1><2><3><4>
res0: List[Int] = List(36, 42)
----
<1> map(_ + 10)은 임시적인 목록을 생성
<2> 그 목록은 filter(_ % 2 == 0)로 전달
<3> filter 는 새로운 목록을 만들어서 map(_ * 3)으로 전달
<4> 최종 목록 생성

* 각 변환은 자신만의 새 목록을 생성
* 그 목록은 다음 변환의 입력으로만 쓰인 후 즉시 폐기
* 평가 과정은 다음과 같을 것이다.


[source,scala]
.목록5.1 List의 프로그램 추적
----
List(1,2,3,4).map(_ + 10).filter(_ % 2 == 0).map(_ * 3)

List(11,12,13,14).filter(_ % 2 == 0).map(_ * 3)

List(12,14).map(_ * 3)

List(36,42)
----

* 임시 자료구조들의 생성을 피하려면 이런 변환들을 하나의 패스로 융합(fusion)
* 하나의 방법으로 while 루프를 작성하는것
* 그보다는 지금처럼 고수준 합성 스타일을 유지하면서 통합이 자동으로 일어나길 원함
* **__비엄격성__**(non-strictness; 비공식적으로 **__나태성__**[laziness])을 이용하면 자동적인 루프 융합이 가능

== 5.1 엄격한 함수와 엄격하지 않은 함수

* **엄격한** 함수는 자신의 인수들을 항상 평가
* 엄격하지 않은 함수는 하나 이상의 인수들을 평가하지 **않을** 수도 있음
* 대부분의 프로그래밍 언어에서는 엄격한 함수만 제공(그리고 기본)
* 스칼라에서도 엄격한 함수가 기본

.엄격한 함수의 예
----
scala> def square(x: Double): Double = x * x <1>
square: (x: Double)Double

scala> square(41.0 + 1.0)
res1: Double = 1764.0 <2>

scala> square(sys.error("failure"))
java.lang.RuntimeException: failure <3>
  at scala.sys.package$.error(package.scala:27)
  ... 30 elided
----
<1> 엄격한 함수 정의
<2> 평가된 값인 42를 받게 된다
<3> 수행하기 전에 예외가 발생

* 아직 엄격하지 않은 함수를 지정하는 구문을 배우지 않음
* 하지만 개념은 익숙함(부울 함수를 통해)
* && 는 첫째 인수가 true일 때에만 둘째 인수를 평가
* || 는 첫째 인수가 false일 때에만 둘째 인수를 평가

.비엄격 함수의 예
----
scala> false && { println("!!"); true}
res4: Boolean = false

scala> true || { println("!!"); false}
res5: Boolean = true
----

* if 제어 구조 역시 비염격성의 예

.비엄격 if 함수의 예
----
scala> val input = List()
input: List[Nothing] = List()

scala> val result = if (input.isEmpty) sys.error("empty input") else input
java.lang.RuntimeException: empty input
  at scala.sys.package$.error(package.scala:27)
  ... 30 elided

scala> val input = List(1)
input: List[Int] = List(1)

scala> val result = if (input.isEmpty) sys.error("empty input") else input
result: List[Int] = List(1)
----

* 내장 언어 구조이지만, 인수가 셋인 함수로 생각
* 첫째 인수는 Boolean 조건 표현식
* 둘째 인수는 조건이 true 이면 A 형식의 값을 돌려주는 표현식
* 셋째 인수는 조건이 false 이면 A 형식의 값을 돌려주는 표현식
* 정확히는 if 는 조건 매개변수에 대해서는 엄격
* 두 분기중 어떤 것을 취할지 결정하려면 조건을 반드시 평가
* 그러나 true, false 두 분기에 대해서는 엄격하지 않음(둘중 하나만 평가)

.비엄격 if 함수
----
scala> def if2[A](cond: Boolean, onTrue: () => A, onFalse: () => A): A =
  if (cond) onTrue() else onFalse()

scala> if2(1 < 2,
     |   () => println("a"),
     |   () => println("b")
     | )
a
----

* () => A 인수를 받지 않고 A를 돌려주는 함수
* 성크(thunk)
* onTrue(), onFalse() 처럼 평가를 강제할 수 있음
* 스칼라는 더 깔끔한 구문을 제공

.더 깔끔한 비엄격 if 함수
----
def if2[A](cond: Boolean, onTrue: => A, onFalse: => A): A =
  if (cond) onTrue else onFalse
----

* 스칼라는 인수 평가의 결과를 캐싱하지 않음(기본적으로는)

.참도될 때마다 평가
----
scala> def maybeTwice(b: Boolean, i: => Int) = if (b) i+i else 0
maybeTwice: (b: Boolean, i: => Int)Int

scala> val x = maybeTwice(true, { println("hi"); 1+41})
hi
hi
x: Int = 84
----

* i는 maybeTwice 본문 안에서 두 번 참조
* 'hi'를 출력해서 **참조될 때마다 평가**되는걸 명시적으로 보여줌
* 캐싱을 적용해서 단 한번만 평가되게 하려면 **lazy** 키워드를 이용

.lazy를 이용한 캐싱
----
scala> def maybeTwice(b: Boolean, i: => Int) = {
     |   lazy val j = i
     |   if (b) j+j else 0
     | }
maybeTwice: (b: Boolean, i: => Int)Int

scala> val x = maybeTwice(true, { println("hi"); 1+41})
hi
x: Int = 84
----

* lazy val 우변이 처음 참조될 때까지 평가 지연
* 평가 결과를 캐시에 담고 평가를 되풀이 하지 않음
* 비엄격 함수의 인수는 값으로(by value) 전달이 아니고 이름으로(by name) 전달

== 5.2 확장 예제: 게으른 목록

* 함수적 프로그램의 효율성과 모듈성을 lazy list 또는 stream 으로 개선

[source,scala]
.목록5.2 stream의 간단한 정의
----
sealed trait Stream[+A]
case object Empty extends Stream[Nothing]
case class Cons[+A](h: => A, t: => Stream[A]) extends Stream[A] <1>

object Stream {
  def cons[A](hd: => A, tl: => Stream[A]): Stream[A] = { <2>
    lazy val head = hd <3>
    lazy val tail = tl <3>
    Cons(() => head, () => tail)
  }

  def empty[A]: Stream[A] = Empty <4>

  def apply[A](as: A*): Stream[A] = <5>
    if (as.isEmpty) empty else cons(as.head, apply(as.tail: _*))
}
----
<1> 기술적인 한계로 이름으로 전달하는 인수가 아니라 명시적으로 강제해야 하는 성크
<2> 비지 않은 스트림의 생성을 위한 똑똑한 생성자
<3> 평가반복을 피하기 위한 캐싱
<4> 빈 스트림 생성을 위한 똑똑한 생성자
<5> Stream 생성을 위한 가변 인수 메서드

.headOption
----
def headOption: Option[A] = this match {
  case Empty = None
  case Cons(h, t) => Some(h()) <1>
}
----
<1> h() 를 이용해서 명시적으로 강제?평가?

=== 5.2.1 스트림의 메모화를 통한 재계산 피하기

* Cons 노드가 평가되면 값을 캐싱해 두는 것이 바람직

.expensive(x)가 두 번 계산
----
val x = Cons(() => expensive(x), tl)
val h1 = x.headOption
val h2 = x.headOption
----

* 위 문제는 실제 생성자와 다른 서명의 똑똑한 생성자를 이용해서 회피
* 첫 글자를 소문자로 바꿔서 사용하는 것이 관례(예, Cons 경우 cons)

[source,scala]
.똑똑한 생성자 역할의 cons 메서드
----
def cons[A](hd: => A, tl => Stream[A]): Stream[A] = { <1>
 lazy val head = hd <2>
 lazy val tail = tl <2>
 Cons(() => head, () => tail)
}
----
<1> 이름으로 전달
<2> 메모화(memoization)를 수행

[source,scala]
.Stream.apply
----
def apply[A](as: A*): Stream[A] = <5>
  if (as.isEmpty) empty
  else cons(as.head, apply(as.tail: _*)) <1>
----
<1> cons 안에서 성크로 감싸는 작업은 스칼라가 처리

=== 5.2.2 스트림의 조사를 위한 보조 함수들

[source,scala]
.5.1 toList
----
def toList: List[A] = {
  @annotation.tailrec
  def go(s: Stream[A], acc: List[A]): List[A] = s match {
    case Cons(h,t) => go(t(), h() :: acc)
    case _ => acc
  }
  go(this, List()).reverse
}

def toListFast: List[A] = {
  val buf = new collection.mutable.ListBuffer[A]
  @annotation.tailrec
  def go(s: Stream[A]): List[A] = s match {
    case Cons(h,t) =>
      buf += h()
      go(t())
    case _ => buf.toList
  }
  go(this)
}
----

[source,scala]
.5.2 take, drop
----
def take(n: Int): Stream[A] = this match {
  case Cons(h, t) if n > 1 => cons(h(), t().take(n-1))
  case Cons(h, _) if n == 1 => cons(h(), empty)
  case _ => empty
}

def drop(n: Int): Stream[A] = this match {
  case Cons(_, t) if n > 0 => t().drop(n - 1)
  case _ => this
}
----

[source,scala]
.5.3 takeWhile
----
def takeWhile(p: A => Boolean): Stream[A] = this match {
  case Cons(h, t) if p(h()) => cons(h(), t().takeWhile(p))
  case _ => empty
}
----
