= 2 스칼라로 함수형 프로그래밍 시작하기
jayden.uk <jinuk17@ggmail.com>
v0.1, 2017-10-11
:toc:

== 개요
* 스칼라와 함수형 프로그래밍
* 스칼라 문법
* 함수적 프로그래밍 기법
** 꼬리 재귀 함수
** 고차 함수
** 다형적 고차 함수

== 2.1 스칼라 언어의 소개: 예제 하나

== 2.2 프로그램의 실행

== 2.3 모듈, 객체, 이름 공간

== 2.4 고차 함수: 함수를 함수에 전달

* 값으로서의 함수
* 고차 함수(higher-order function. HOF)

=== 2.4.1 잠깐 곁가지: 함수적으로 루프 작성하기
===== 반복문을 함수적으로 작성하는 방법
반복문 내부적으로 상태를 저장/변경하는 것(부수효과)을 재귀 함수 이용하여 해결

===== 꼬리 호출 제거(tail call elimination) 최적화

스칼라 컴파일러는 자기 재귀(self-recursion)를 검출해서 +
꼬리 재귀(tail recursion)일 경우 while loop 를 사용했을 때와 같은 종류의 바이트 코드로 컴파일 +
=> stackover flow 해결

TIP: @tailrec 주석을 이용해서 컴파일 단계에서 꼬리 재귀를 검출할 수 있다.

[source, Scala]
----
//꼬리재귀 X
def factorial(i: Int): Int = {
  if( i == 1 ) i
  else i * factorial1(i - 1)
}

//꼬리재귀 O
def factorial(n: Int): Int = {
  @tailrec
  def go(n: Int, acc: Int): Int =
    if (n <= 0) acc
    else go(n-1, n*acc)

  go(n, 1)
}
----

=== 2.4.2 첫 번째 고차 함수 작성

===== 고차 함수
함수를 인자로 받는 함수

[source,scala]
----
def formatAbs(x: Int) = {
  val msg = "The absolute value of %d is %d."
  msg.format(x, abs(x))
}

def formatFactorial(n: Int) = {
  val msg = "The factorial of %d is %d."
  msg.format(n, Factorial(n))
}
----

[source,scala]
----
def formatResult(name: String, n: Int , f: Int => Int) = {
  val msg = "The %s of %d is %d."
  msg.format(name, n, f(n))
}

formatResult("absolute value", -42, abs)
formatResult("factorial", 7, factorial)
----

== 2.5 다형적 함수: 형식에 대한 추상
[%hardbreaks]
===== 단형적 함수 (momomorhic function)
한 형식에의 자료에만 작용하는 함수
===== 다형적 함수 (polymorphic function)
 임의의 형식에 대해 작동하는 함수

=== 2.5.1 다형적 함수의 예

[source,scala]
----
def findFirst (ss: Array[String], key: String): Int = {
  @annotation.tailrec
  def loop(n: Int): Int =
    if(n >= ss.length) -1
    else if (ss(n) == key)) n
    else loop(n + 1)

  loop(0)
}
----

[source,scala]
----
def findFirst[A] (as: Array[A], p: A => Boolean): Int = {
    @annotation.tailrec
    def loop(n: Int): Int =
      if(n >= as.length) -1
      else if (p(as(n))) n
      else loop(n + 1)

    loop(0)
}
----

=== 2.5.2 익명 함수로 고차 함수 호출

고차함수를 호출할 때, 기존의 이름 붙은 함수를 인수로 지정해서 호출하는 것이 아니라 익명 함수(anonymous function) 또는 함수 리터럴(function literal)을 지정해서 호출하는 것이 편리함.

[source,scala]
----
//이름 붙은 함수 인자
formatResult("absolute value", -42, abs)

//익명 함수 인자
formatResult("absolute value", -42, (x: Int) => if(x < 0) -n else n)
----

===== 스칼라에서 값으로서의 함수
함수 리터럴 정의할 때, 실제로 apply 라는 메서드를 가진 객체이다. apply 라는 메서드를 가진 객체는 그 자체를 메서드인 것 처럼 호출 할 수가 있다.

[source,scala]
----
// 함수 리터럴
val lessThan = (a: Int, b: Int): Boolean => a < b

// 실제 생성되는 객체
val lessThan = new Function2[Int, Int, Boolean] {
 def apply(a: Int, b:Int) = a < b
}
----

NOTE: 스칼라 라이브러리에서는 Function0~22의 trait을 지원 (Scala version 2.11.8 기준)


== 2.6 형식에서 도출된 구현

===== 부분 적용
인자 목록이 둘 이상 있는 함수의 경우, 필요한 인자 중 일부만 적용해 새로운 함수를 정의

[source,scala]
----
def partial1[A,B,C](a: A, f:(A,B) => C): B => C = {
  (b: B) => f(a, b)
}
----

===== 커링
여러 인자를 취하는 함수를 단 하나의 인자를 취하는 여러 함수의 연속으로 변환
[source,scala]
----
def uncurried(a: Int, b: String, c: Boolean): Boolean = true
var curried: (Int) => (String) => (Boolean) => Boolean = (uncurried _).curried
----
NOTE: 스칼라 라이브러리 Function0, 1을 제외한 FunctionN trait 에서 커링을 위한 curried 제공

===== 함수 합성 (compose, andThen)

스칼라 라이브러리에서는 Function1 trait 에서 함수 합성을 위한 compose와 andThen 제공

[source,scala]
----
val f = (x: Int) => x.toString
val g = (s: String) => s.toInt

val stringToString: (String) => String = f compose g
//f(g("10"))

var intToInt1: (Int) => Int = f andThen g
//g(f(10))

var intToInt2: (Int) => Int = g compose f
----
